{"version":3,"sources":["../../src/browser-utils/utils.js"],"names":["stream","require","toNodeStream","reader","size","nodeStream","Readable","lineCounter","lastString","decoder","TextDecoder","done","value","read","cancel","string","decode","lines","split","pop","line","push","isFileFromBrowser","file","File","module","exports"],"mappings":";;;;;;;;AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;AAEA;;;;;;;;AAMA,MAAMC,YAAY;AAAA,+BAAG,WAAOC,MAAP,EAAeC,IAAf,EAAwB;AAC3C;AACA;AACA,UAAMC,UAAU,GAAG,IAAIL,MAAM,CAACM,QAAX,EAAnB;AAEA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,UAAU,GAAG,EAAjB;AACA,UAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;;AAEA,WAAO,IAAP,EAAa;AACX,YAAM;AAAEC,QAAAA,IAAF;AAAQC,QAAAA;AAAR,UAAkB,MAAMT,MAAM,CAACU,IAAP,EAA9B;;AAEA,UAAIF,IAAI,IAAKJ,WAAW,GAAGH,IAAd,IAAsBA,IAAI,KAAK,CAA5C,EAAgD;AAC9CD,QAAAA,MAAM,CAACW,MAAP;AACA;AACD,OANU,CAQX;;;AACA,YAAMC,MAAM,aAAMP,UAAN,SAAmBC,OAAO,CAACO,MAAR,CAAeJ,KAAf,CAAnB,CAAZ,CATW,CAWX;;AACA,YAAMK,KAAK,GAAGF,MAAM,CAACG,KAAP,CAAa,cAAb,CAAd,CAZW,CAcX;;AACAV,MAAAA,UAAU,GAAGS,KAAK,CAACE,GAAN,MAAe,EAA5B;;AAEA,WAAK,MAAMC,IAAX,IAAmBH,KAAnB,EAA0B;AACxB,YAAIV,WAAW,KAAKH,IAApB,EAA0B,MADF,CAExB;;AACAC,QAAAA,UAAU,CAACgB,IAAX,CAAgBD,IAAI,GAAG,MAAvB;AACAb,QAAAA,WAAW;AACZ;AACF;;AAEDF,IAAAA,UAAU,CAACgB,IAAX,CAAgB,IAAhB;AACA,WAAOhB,UAAP;AACD,GApCiB;;AAAA,kBAAZH,YAAY;AAAA;AAAA;AAAA,IAAlB;;AAsCA,MAAMoB,iBAAiB,GAAIC,IAAD,IAAU;AAClC,SAAOA,IAAI,YAAYC,IAAvB;AACD,CAFD;;AAIAC,MAAM,CAACC,OAAP,GAAiB;AACfxB,EAAAA,YAAY,EAAEA,YADC;AAEfoB,EAAAA,iBAAiB,EAAEA;AAFJ,CAAjB","sourcesContent":["const stream = require('stream')\n\n/**\n * Return node like stream so that parsers work.\n * Transform browser's Reader to string, then create a nodejs stream from it\n * @param {object} reader\n * @param {number} size\n */\nconst toNodeStream = async (reader, size) => {\n  // if in browser, return node like stream so that parsers work\n  // Running in browser:\n  const nodeStream = new stream.Readable()\n\n  let lineCounter = 0\n  let lastString = ''\n  const decoder = new TextDecoder()\n\n  while (true) {\n    const { done, value } = await reader.read()\n\n    if (done || (lineCounter > size && size !== 0)) {\n      reader.cancel()\n      break\n    }\n\n    // Decode the current chunk to string and prepend the last string\n    const string = `${lastString}${decoder.decode(value)}`\n\n    // Extract lines from chunk\n    const lines = string.split(/\\r\\n|[\\r\\n]/g)\n\n    // Save last line, as it might be incomplete\n    lastString = lines.pop() || ''\n\n    for (const line of lines) {\n      if (lineCounter === size) break\n      // Write each string line to our nodejs stream\n      nodeStream.push(line + '\\r\\n')\n      lineCounter++\n    }\n  }\n\n  nodeStream.push(null)\n  return nodeStream\n}\n\nconst isFileFromBrowser = (file) => {\n  return file instanceof File\n}\n\nmodule.exports = {\n  toNodeStream: toNodeStream,\n  isFileFromBrowser: isFileFromBrowser,\n}\n"],"file":"utils.js"}