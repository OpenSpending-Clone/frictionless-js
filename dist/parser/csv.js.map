{"version":3,"sources":["../../src/parser/csv.js"],"names":["parse","require","CSVSniffer","toString","iconv","csvParser","file","keyed","size","parseOptions","getParseOptions","stream","descriptor","encoding","toLowerCase","replace","pipe","decodeStream","guessParseOptions","possibleDelimiters","sniffer","text","displayName","end","bytes","Promise","resolve","reject","on","chunk","length","pause","results","sniff","delimiter","quote","quoteChar","columns","ltrim","dialect","rowDelimiter","lineTerminator","doubleQuote","undefined","escape","guessedParseOptions","Object","assign","Uint8ArrayToStringsTransformer","constructor","decoder","TextDecoder","lastString","transform","controller","string","decode","lines","split","pop","line","enqueue","flush","module","exports"],"mappings":"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","sourcesContent":["const parse = require('csv-parse')\nconst CSVSniffer = require('csv-sniffer')()\nconst toString = require('stream-to-string')\nconst iconv = require('iconv-lite')\n\nconst csvParser = async (file, { keyed = false, size = 0 } = {}) => {\n  const parseOptions = await getParseOptions(file, keyed)\n  let stream = await file.stream({ size })\n  if (file.descriptor.encoding.toLowerCase().replace('-', '') === 'utf8') {\n    return stream.pipe(parse(parseOptions))\n  } else {\n    // non utf-8 files are decoded by iconv-lite module\n    return stream\n      .pipe(iconv.decodeStream(file.descriptor.encoding))\n      .pipe(parse(parseOptions))\n  }\n}\n\nconst guessParseOptions = async (file) => {\n  const possibleDelimiters = [',', ';', ':', '|', '\\t', '^', '*', '&']\n  const sniffer = new CSVSniffer(possibleDelimiters)\n  let text = ''\n  // We assume that reading first 50K bytes is enough to detect delimiter, line terminator etc.:\n  if (file.displayName === 'FileLocal') {\n    const stream = await file.stream({ end: 50000 })\n    text = await toString(stream)\n  } else if (file.displayName === 'FileInterface') {\n    text = await file.descriptor.text()\n  } else if (file.displayName === 'FileRemote') {\n    const stream = await file.stream({ size: 100 })\n    let bytes = 0\n    await new Promise((resolve, reject) => {\n      stream\n        .on('data', (chunk) => {\n          bytes += chunk.length\n          if (bytes > 50000) {\n            stream.pause()\n            resolve()\n          } else {\n            text += chunk.toString()\n          }\n        })\n        .on('end', () => {\n          resolve()\n        })\n    })\n  }\n  const results = sniffer.sniff(text)\n  return {\n    delimiter: results.delimiter,\n    quote: results.quoteChar || '\"',\n  }\n}\n\nconst getParseOptions = async (file, keyed) => {\n  let parseOptions = {\n    columns: keyed ? true : null,\n    ltrim: true,\n  }\n  if (file.descriptor.dialect) {\n    parseOptions.delimiter = file.descriptor.dialect.delimiter || ','\n    parseOptions.rowDelimiter = file.descriptor.dialect.lineTerminator\n    parseOptions.quote = file.descriptor.dialect.quoteChar || '\"'\n    if (\n      file.descriptor.dialect.doubleQuote !== undefined &&\n      file.descriptor.dialect.doubleQuote === false\n    ) {\n      parseOptions.escape = ''\n    }\n  } else {\n    const guessedParseOptions = await guessParseOptions(file)\n    // Merge guessed parse options with default one:\n    parseOptions = Object.assign(parseOptions, guessedParseOptions)\n  }\n\n  return parseOptions\n}\n\n/**\n * This transformer takes binary Uint8Array chunks from a `fetch`\n * and translates them to chunks of strings.\n *\n * @implements {TransformStreamTransformer}\n */\nclass Uint8ArrayToStringsTransformer {\n  constructor() {\n    this.decoder = new TextDecoder()\n    this.lastString = ''\n  }\n\n  /**\n   * Receives the next Uint8Array chunk from `fetch` and transforms it.\n   *\n   * @param {Uint8Array} chunk The next binary data chunk.\n   * @param {TransformStreamDefaultController} controller The controller to enqueue the transformed chunks to.\n   */\n  transform(chunk, controller) {\n    // Decode the current chunk to string and prepend the last string\n    const string = `${this.lastString}${this.decoder.decode(chunk)}`\n\n    // Extract lines from chunk\n    const lines = string.split(/\\r\\n|[\\r\\n]/g)\n\n    // Save last line, as it might be incomplete\n    this.lastString = lines.pop() || ''\n\n    // Enqueue each line in the next chunk\n    for (const line of lines) {\n      controller.enqueue(line)\n    }\n  }\n\n  /**\n   * Is called when `fetch` has finished writing to this transform stream.\n   *\n   * @param {TransformStreamDefaultController} controller The controller to enqueue the transformed chunks to.\n   */\n  flush(controller) {\n    // Is there still a line left? Enqueue it\n    if (this.lastString) {\n      controller.enqueue(this.lastString)\n    }\n  }\n}\n\nmodule.exports = {\n  csvParser,\n  getParseOptions,\n  guessParseOptions,\n  Uint8ArrayToStringsTransformer,\n}\n"],"file":"csv.js"}